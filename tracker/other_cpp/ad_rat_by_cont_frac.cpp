#include <iostream>
#include <cmath>
#include <string>
#include <getopt.h>
#include <cassert>

// find the best rational approximation n/d where d <= l to the given
// target number t. here the best means the one with the smallest
// absolute error between t and n/d.

// (based on the original comment by d. eppstein) based on the theory
// of continued fractions, if x = a1 + 1/(a2 + 1/(a3 + 1/(a4 + ...)))
// then the best approximation is found by truncating this series, with
// some adjustments due to l. the fraction can be recovered by the 1st
// column of the matrix:
//   (1 0) (a1 1) (a2 1) (a3 1) ...
//   (0 1) (1  0) (1  0) (1  0)
// instead of keeping the sequence of continuted fraction terms, we
// just keep the last partial product of these matrics.

// author: ali dasdan (based on the C code by d. eppstein)

// generated by
// https://app.codeconvert.ai/code-converter?inputLang=Python&outputLang=C%2B%2B
// from:
// https://github.com/alidasdan/best-rational-approximation
// https://github.com/alidasdan/best-rational-approximation/blob/master/ad_rat_by_cont_frac.py

// The Python code has been translated to C++ while maintaining the same functionality and algorithm.
// Key changes made in the translation:
// Replaced Python's tuple returns with a C++ struct RationalResult
// Used C++'s getopt_long for command line argument parsing
// Replaced Python's dynamic typing with C++'s static typing
// Used C++ standard library functions instead of Python built-ins
// Implemented proper error handling using try-catch blocks
// Replaced Python's string formatting with C-style printf for output formatting
// The mathematical algorithm remains identical to the original Python version
// The program structure and flow remain the same, just adapted to C++ idioms
// Note that the Python eval() functionality for the target parameter has been removed 
// for security reasons and replaced with direct floating-point parsing


void show_usage(const char* program_name) {
    std::cout << program_name << " -h/--help [-e/--error=float>=0] -l/--limit=int>1 -t/--target=float" << std::endl;
}


char program_name[64] = "ad_rat_by_cont_frac.cpp";
void at_exit(const std::string& msg) {
    if (!msg.empty()) {
        std::cout << "Error: " << msg << std::endl;
    }
    show_usage(program_name);
    exit(0);
}

// this function takes in an int limit l and the target fraction to
// approximate t and returns err, n, d, niter where n/d is the
// approximate rational for t, err is the error, and niter is the
// number of iterations of the loop. note that the err is not the
// absolute error.
struct RationalResult {
    // this struct has to be in this order because there are returns that set some?
    /// i.e return {err, n, d, niter};
    double err;
    int n;
    int d;
    int niter;

    double error; // kbn err..for consistency with other algo
    long numerator; // kbn n..for consistency with other algo
    long denominator; // kbn d..for consistency with other algo
    int iterations; // kbn niter..for consistency with other algo

    double actual_real;  // kbn
    double actual_error; // kbn
    double target; // kbn

};

RationalResult find_best_rat(int l, double t) {
    assert(l >= 1);

    // handle the trivial case
    if (t <= 0) {
        return {0, static_cast<int>(t), 1, 0};
    }

    // initialize the matrix
    int m00 = 1, m01 = 0;
    int m10 = 0, m11 = 1;
    
    // loop finding terms until denom gets too big
    double x = t;
    int ai = static_cast<int>(x);
    int niter = 0;
    
    while ((m10 * ai + m11) <= l) {
        niter++;

        // multiply these two matrices:
        //    (m00 m10) and (ai 1)
        //    (m10 m11)     (1  0)
        int tmp = m00 * ai + m01;
        m01 = m00;
        m00 = tmp;
        tmp = m10 * ai + m11;
        m11 = m10;
        m10 = tmp;
        
        if (x == static_cast<double>(ai)) break;
        x = 1.0 / (x - static_cast<double>(ai));
        ai = static_cast<int>(x);
    }

    // now remaining x is between 0 and 1/ai. approx as either o or 1/m
    // where m is max that will fit in l.
    
    // first try zero
    int n1 = m00;
    int d1 = m10;
    double err1 = (t - static_cast<double>(n1) / d1);

    // try the other possibility
    ai = static_cast<int>(static_cast<double>(l - m11) / m10);
    int n2 = m00 * ai + m01;
    int d2 = m10 * ai + m11;
    double err2 = (t - static_cast<double>(n2) / d2);

    if (std::abs(err1) <= std::abs(err2)) {
        return {err1, n1, d1, niter};
    } else {
        return {err2, n2, d2, niter};
    }
}

// this function takes in an error bound err_in, an int limit l, and
// the target fraction to approximate t and returns err_out, n, d,
// niter where n/d is the approximate rational for t with d<=l, err_out
// is the error whose absolute value is at most err_in, and niter is
// the number of iterations of the loop.
RationalResult find_best_rat_with_err_bound(double err_in, int l, double t) {
    int l_curr = 1;
    int sum_niter = 0;
    RationalResult result = find_best_rat(l_curr, t);
    
    while (std::abs(result.err) > err_in && l_curr < l) {
        l_curr *= 10;
        sum_niter += result.niter;
        result = find_best_rat(l_curr, t);
    }
    result.niter = sum_niter;
    return result;
}

int main2(int argc, char* argv[]) {
    double eps = -1;
    int l = -1;
    double t = -1;

    static struct option long_options[] = {
        {"help", no_argument, 0, 'h'},
        {"error", required_argument, 0, 'e'},
        {"limit", required_argument, 0, 'l'},
        {"target", required_argument, 0, 't'},
        {0, 0, 0, 0}
    };

    int opt;
    while ((opt = getopt_long(argc, argv, "he:l:t:", long_options, nullptr)) != -1) {
        try {
            switch (opt) {
                case 'h':
                    show_usage(argv[0]);
                    return 0;
                case 'e':
                    eps = std::stod(optarg);
                    if (eps <= 0) throw std::runtime_error("Error must be positive");
                    break;
                case 'l':
                    l = std::stoi(optarg);
                    if (l < 1) throw std::runtime_error("Limit must be greater than 0");
                    break;
                case 't':
                    t = std::stod(optarg);
                    if (t <= 0) throw std::runtime_error("Target must be positive");
                    break;
                default:
                    throw std::runtime_error("Invalid option");
            }
        } catch (const std::exception& e) {
            at_exit(e.what());
        }
    }

    if (t == -1 || l == -1) {
        at_exit("Target and limit args are required");
    }

    RationalResult result;
    if (eps == -1) {
        result = find_best_rat(l, t);
    } else {
        result = find_best_rat_with_err_bound(eps, l, t);
    }

    result.error = result.err; // kbn ..for consistency with other algo
    result.numerator = result.n; // kbn ..for consistency with other algo
    result.denominator = result.d; // kbn ..for consistency with other algo
    result.iterations = result.niter; // kbn ..for consistency with other algo

    if (eps == -1) {
        printf("target= %f best_rat= %d / %d max_denom= %d err= %g abs_err= %g niter= %d\n",
               t, result.n, result.d, l, result.err, std::abs(result.err), result.niter);
    } else {
        printf("target= %f best_rat= %d / %d max_denom= %d err= %g abs_err= %g abs_err/error= %g niter= %d\n",
               t, result.n, result.d, l, result.err, std::abs(result.err), 
               std::abs(result.err) / eps, result.niter);
    }

    return 0;
}
